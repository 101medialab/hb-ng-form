{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://hb-ng-form/lib/components/hb-form-widget.component.ts","ng://hb-ng-form/lib/components/hb-form-array.component.ts","ng://hb-ng-form/lib/components/hb-form-mat-array.component.ts","ng://hb-ng-form/lib/components/hb-form-object.component.ts","ng://hb-ng-form/lib/components/hb-form-mat-object.component.ts","ng://hb-ng-form/lib/components/hb-form-mat-widget.component.ts","ng://hb-ng-form/lib/ObjectAttributeTypeExtractor.ts","ng://hb-ng-form/lib/class/decorators/FormConfig.ts","ng://hb-ng-form/lib/class/decorators/ArrayOptions.ts","ng://hb-ng-form/lib/class/decorators/ObjectOptions.ts","ng://hb-ng-form/lib/class/decorators/AutocompleteOptions.ts","ng://hb-ng-form/lib/class/decorators/ChoiceOptions.ts","ng://hb-ng-form/lib/class/decorators/MultipleChoicesOptions.ts","ng://hb-ng-form/lib/class/decorators/FlexibleObjectArray.ts","ng://hb-ng-form/lib/class/decorators/MatExtraOptions.ts","ng://hb-ng-form/lib/class/NgFormFactoryDecorators.ts","ng://hb-ng-form/lib/class/Ng2FormFactory.ts","ng://hb-ng-form/lib/pipe/MapToIterable.ts","ng://hb-ng-form/lib/HbFormModule.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__metadata","metadataKey","metadataValue","metadata","__values","o","s","Symbol","iterator","m","call","next","value","done","TypeError","__read","n","e","ar","push","error","__spread","concat","HbFormWidgetComponent","resolver","log","args","_i","console","apply","ngAfterViewInit","data","hide","useComponent","factory","resolveComponentFactory","ref","customBlock","createComponent","instance","templateObject","parentTemplateObject","parent","changeDetectorRef","detectChanges","isOptionSelectingComponent","indexOf","renderType","ngOnInit","result","resolved_1","options","type","name","label","Error","diContainer","Observable","complete","resolvedOptions","stringToBoolean","val","updateParentValue","$event","option","source","isChecked","checked","parentControls","control","controls","add","setValue","remove","patchValue","typeof","input","slugifyString","HbFormWidgetComponent_1","slugMap","toLowerCase","replace","ComponentFactoryResolver","ViewChild","read","ViewContainerRef","static","Component","selector","template","inputs","HbFormArrayComponent","_super","HbFormMatArrayComponent","HbFormObjectComponent","HbFormMatObjectComponent","HbFormMatWidgetComponent","arrayType","TypeMeta","_type","PrimitiveTypeMeta","_value","_this","NonPrimitiveTypeMeta","_mapping","OnOATResolved","cb","ObjectAttributeTypeExtractor","generateMapping","assign","keyNamingStrategy","stripUnderscore","mapping","Extractor","resolvedMeta","generateObjectTypeMapping","hasMetadata","getMetadata","onResolved","resolveAttributeKey","Date","object","setterKey","charAt","trimmedKey","substr","convertStringToSnakeCase","fixNamingConvention","forEach","obj","finalKey","convertDataToString","callbacks","date","Function","yyyymmdd","FormConfigSymbol","ArrayOptionsSymbol","ObjectOptionsSymbol","AutocompleteSymbol","ChoiceOptionsSymbol","FormControl","MultipleChoicesOptionsSymbol","FlexibleObjectArraySymbol","MatExtraOptionsSymbol","onOATResolved","resolved","formFactory","eachSymbol","getMetadataArgs","Ng2FormFactory","generateFormGroupByObject","formBuilder","resolveTypeAny","generateFormGroupByOATMapping","generateLabel","fixedKey","toUpperCase","slice","attributeMappingObject","resolveTypeUndefined","ngFormControl","templateConfig","isNonPrimitiveType","attrMapping","currentTemplateConfig","current","handleArray","child","prepareAndCreateChildTemplateConfig","groupType","FormGroup","resolveFormValidators","validators","children","_a","valueNotEmpty","factorySetValueFunctionToTemplate","resolveTemplateConfigByType","setTemplatePreset","undefined","Validators","required","currentInput","isRaw","schemaTemp","onCreate","ngFormArrayControl","FormArray","initChildren","childrenConfigName","useConfig","objectDefinitions","i_1","each","structure","childConfig","flexibleObjectTypeName","onPush","removeAt","splice","rawValue","targetTemplate","beforeSetValue","afterSetValue","i_2","resolveFlexibleObjectArrayConfig","fixForPrimitiveArray","templateObj","expandOptions","maxChoices","Map","MapToIterable","transform","_b","keys","_c","Pipe","directivesAndPipes","HbFormModule","NgModule","imports","FormsModule","ReactiveFormsModule","BrowserAnimationsModule","MatAutocompleteModule","MatButtonModule","MatButtonToggleModule","MatCardModule","MatCheckboxModule","MatDatepickerModule","MatExpansionModule","MatInputModule","MatNativeDateModule","MatRadioModule","MatSelectModule","declarations","exports","autocomplete","slug","hiderHeader"],"mappings":";;;;;;;;;;;;;;oFAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GA0B5E,SAASK,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2HlB,EAAvHmB,EAAIC,UAAUC,OAAQC,EAAIH,EAAI,EAAIH,EAAkB,OAATE,EAAgBA,EAAOhB,OAAOqB,yBAAyBP,EAAQC,GAAOC,EACrH,GAAuB,iBAAZM,SAAoD,mBAArBA,QAAQC,SAAyBH,EAAIE,QAAQC,SAASV,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAIQ,EAAIX,EAAWM,OAAS,EAAGK,GAAK,EAAGA,KAAS1B,EAAIe,EAAWW,MAAIJ,GAAKH,EAAI,EAAInB,EAAEsB,GAAKH,EAAI,EAAInB,EAAEgB,EAAQC,EAAKK,GAAKtB,EAAEgB,EAAQC,KAASK,GAChJ,OAAOH,EAAI,GAAKG,GAAKpB,OAAOyB,eAAeX,EAAQC,EAAKK,GAAIA,EAOzD,SAASM,EAAWC,EAAaC,GACpC,GAAuB,iBAAZN,SAAoD,mBAArBA,QAAQO,SAAyB,OAAOP,QAAQO,SAASF,EAAaC,GA6C7G,SAASE,EAASC,GACrB,IAAIC,EAAsB,mBAAXC,QAAyBA,OAAOC,SAAUC,EAAIH,GAAKD,EAAEC,GAAIR,EAAI,EAC5E,GAAIW,EAAG,OAAOA,EAAEC,KAAKL,GACrB,GAAIA,GAAyB,iBAAbA,EAAEZ,OAAqB,MAAO,CAC1CkB,KAAM,WAEF,OADIN,GAAKP,GAAKO,EAAEZ,SAAQY,OAAI,GACrB,CAAEO,MAAOP,GAAKA,EAAEP,KAAMe,MAAOR,KAG5C,MAAM,IAAIS,UAAUR,EAAI,0BAA4B,mCAGjD,SAASS,EAAOV,EAAGW,GACtB,IAAIP,EAAsB,mBAAXF,QAAyBF,EAAEE,OAAOC,UACjD,IAAKC,EAAG,OAAOJ,EACf,IAAmBX,EAAYuB,EAA3BnB,EAAIW,EAAEC,KAAKL,GAAOa,EAAK,GAC3B,IACI,WAAc,IAANF,GAAgBA,KAAM,MAAQtB,EAAII,EAAEa,QAAQE,MAAMK,EAAGC,KAAKzB,EAAEkB,OAExE,MAAOQ,GAASH,EAAI,CAAEG,MAAOA,GACjC,QACQ,IACQ1B,IAAMA,EAAEmB,OAASJ,EAAIX,EAAU,SAAIW,EAAEC,KAAKZ,GAE1D,QAAkB,GAAImB,EAAG,MAAMA,EAAEG,OAE7B,OAAOF,EAGJ,SAASG,IACZ,IAAK,IAAIH,EAAK,GAAIpB,EAAI,EAAGA,EAAIN,UAAUC,OAAQK,IAC3CoB,EAAKA,EAAGI,OAAOP,EAAOvB,UAAUM,KACpC,OAAOoB,mBCjHP,SAAAK,EACYC,GAAA1C,KAAA0C,SAAAA,QA+HhB,SAzIaD,EAcTA,EAAAvC,UAAAyC,IAAA,eAAI,IAAAC,EAAA,GAAAC,EAAA,EAAAA,EAAAnC,UAAAC,OAAAkC,IAAAD,EAAAC,GAAAnC,UAAAmC,GACAC,QAAQH,IAAGI,MAAXD,QAAOP,EAAQK,KAGnBH,EAAAvC,UAAA8C,gBAAA,WACI,IAAKhD,KAAKiD,KAAKC,MAAQlD,KAAKiD,KAAKE,aAAc,CAC3C,IAAMC,EAAUpD,KAAK0C,SAASW,wBAC1BrD,KAAKiD,KAAKE,cAERG,EAAMtD,KAAKuD,YAAYC,gBAAgBJ,GAC7CE,EAAIG,SAASC,eAAiB1D,KAAKiD,KACnCK,EAAIG,SAASE,qBAAuB3D,KAAK4D,OAEzCN,EAAIO,kBAAkBC,kBAI9BrB,EAAAvC,UAAA6D,2BAAA,WACI,MAAO,CAAC,QAAS,WAAY,UAAUC,QAAQhE,KAAKiD,KAAKgB,aAAe,GAG5ExB,EAAAvC,UAAAgE,SAAA,WACI,GAAIlE,KAAK+D,6BAA8B,CACnC,IAAId,EAAOjD,KAAKiD,KAEZkB,EAAS,KACTC,EAAW,KAEXC,EAAe,GAkBnB,GAhBIpB,EAAKoB,UACDpB,EAAKoB,QAAQ1D,QACW,mBAAjBsC,EAAKoB,SAGhBA,EAAUpB,EAAKoB,QAED,YAAdpB,EAAKqB,MACe,aAApBrB,EAAKgB,aAELI,EAAU,CAAC,CACPE,KAAMtB,EAAKuB,MACX1C,OAAO,KAIQ,IAAnBuC,EAAQ1D,OACR,MAAM,IAAI8D,MAAM,sBAAwBxB,EAAK1C,IAAM,OAASP,KAAK4D,OAAOrD,KAGrD,mBAAZ8D,EACPD,EAAWC,EAAQpB,EAAKyB,YAAa1E,KAAKiD,KAAMjD,KAAK4D,QAC5CO,aAAkBQ,EAAAA,aAC3BP,EAAWC,GAGfF,EAASC,EAEHA,aAAoBO,EAAAA,aACtBR,EAAS,IAAIQ,EAAAA,YAAW,SAACpD,GACrBA,EAAEM,KAAKuC,GACP7C,EAAEqD,eAIV5E,KAAK6E,gBAAkBV,IAI/B1B,EAAAvC,UAAA4E,gBAAA,SAAgBC,GACZ,MAAe,SAARA,GAGXtC,EAAAvC,UAAA8E,kBAAA,SAAkBC,EAAQC,GACtB,IAAM5E,EAAS2E,EAAO3E,OAAS2E,EAAO3E,OAAS2E,EAAOE,OAClDC,EAAY9E,EAAO+E,QAEvB,OAAQrF,KAAKiD,KAAKgB,YACd,IAAK,WACD,IAAIqB,EAAiBtF,KAAK4D,OAAO2B,QAAQC,SAEzC,GAAIJ,EACApF,KAAK4D,OAAO6B,MAEZH,EAAeA,EAAe3E,OAAS,GAAG+E,SAASR,EAAOpD,WACvD,CAGH,IAFA,IAAId,EAAI,EAEDA,EAAIsE,EAAe3E,QAClB2E,EAAetE,GAAGc,OAASoD,EAAOpD,MADRd,KAIlChB,KAAK4D,OAAO+B,OAAO3E,GAGvB,MAEJ,IAAK,QACGoE,GAAWpF,KAAKiD,KAAKsC,QAAQK,WAAWtF,EAAOwB,SAM/DW,EAAAvC,UAAA2F,OAAA,SAAOC,GACH,cAAcA,GAGlBrD,EAAAvC,UAAA6F,cAAA,SAAcD,GACV,GAAIA,KAASE,EAAsBC,QAC/B,OAAOD,EAAsBC,QAAQH,GAGzC,GAAIA,EACA,OAAOE,EAAsBC,QAAQH,GAASA,EACzCI,cACAC,QAAQ,YAAa,IACrBA,QAAQ,WAAY,KACpBA,QAAQ,WAAY,IAEzB,MAAM,IAAI1B,MAAM,8CAjIjBhC,EAAAwD,QAAU,4CAKKG,EAAAA,4BAH8ChG,EAAA,CAAnEiG,EAAAA,UAAU,cAAe,CAAEC,KAAMC,EAAAA,iBAAkBC,QAAQ,+DAPnD/D,EAAqBuD,EAAA5F,EAAA,CALjCqG,EAAAA,UAAU,CACPC,SAAU,iBACVC,SAAA,0wNACAC,OAAQ,CAAC,OAAQ,MAAO,mCAYFR,EAAAA,4BAVb3D,oBCXb,SAAAoE,mDACA,OAD0C/G,EAAA+G,EAAAC,GAA7BD,EAAoBzG,EAAA,CALhCqG,EAAAA,UAAU,CACPC,SAAU,gBACVC,SAAA,yoHACAC,OAAQ,CAAC,MAAO,OAAQ,aAEfC,IAA6BpE,iBCA1C,SAAAsE,mDACA,OAD6CjH,EAAAiH,EAAAD,GAAhCC,EAAuB3G,EAAA,CALnCqG,EAAAA,UAAU,CACPC,SAAU,oBACVC,SAAA,6kIACAC,OAAQ,CAAC,MAAO,OAAQ,aAEfG,IAAgCF,iBCA7C,SAAAG,mDACA,OAD2ClH,EAAAkH,EAAAF,GAA9BE,EAAqB5G,EAAA,CALjCqG,EAAAA,UAAU,CACPC,SAAU,iBACVC,SAAA,8xDACAC,OAAQ,CAAC,KAAM,MAAO,OAAQ,aAErBI,IAA8BvE,iBCA3C,SAAAwE,mDACA,OAD8CnH,EAAAmH,EAAAH,GAAjCG,EAAwB7G,EAAA,CALpCqG,EAAAA,UAAU,CACPC,SAAU,qBACVC,SAAA,o9DACAC,OAAQ,CAAC,KAAM,MAAO,OAAQ,aAErBK,IAAiCD,iBCA9C,SAAAE,mDAaA,OAb8CpH,EAAAoH,EAAAJ,GAC1CI,EAAAhH,UAAAgE,SAAA,WACI4C,EAAA5G,UAAMgE,SAAQtC,KAAA5B,MAGe,QAAzBA,KAAK4D,OAAOuD,WACZnH,KAAK4D,OAAO2B,QAAQzD,MAAMkC,QAAQhE,KAAKiD,KAAKoB,QAAQ,GAAGvC,QAAU,GAEjE9B,KAAKiD,KAAKsC,QAAQG,SACd1F,KAAKiD,KAAKoB,QAAQ,GAAGvC,QATxBoF,EAAwB9G,EAAA,CALpCqG,EAAAA,UAAU,CACPC,SAAU,qBACVC,SAAA,w3NACAC,OAAQ,CAAC,OAAQ,MAAO,aAEfM,IAAiCzE,gBCL1C,SAAA2E,EAAsBC,GAAArH,KAAAqH,MAAAA,EAK1B,OAHI7H,OAAAyB,eAAImG,EAAAlH,UAAA,OAAI,KAAR,WACI,OAAOF,KAAKqH,uCAEpBD,mBAGI,SAAAE,EACcC,GADd,IAAAC,EAGIV,EAAAlF,KAAA5B,KACoB,CACZ,SACA,SACA,WACFgE,eAAeuD,IAAW,SAAWA,EAAS,QACnDvH,YARSwH,EAAAD,OAAAA,IAclB,OAhBuCzH,EAAAwH,EAAAR,GAanCtH,OAAAyB,eAAIqG,EAAApH,UAAA,QAAK,KAAT,WACI,OAAOF,KAAKuH,wCAEpBD,GAhBuCF,iBAmBnC,SAAAK,EACInD,EACQoD,EACAH,QADA,IAAAG,IAAAA,EAAA,WACA,IAAAH,IAAAA,EAAA,MAHZ,IAAAC,EAKIV,EAAAlF,KAAA5B,KAAMsE,IAAKtE,YAHHwH,EAAAE,SAAAA,EACAF,EAAAD,OAAAA,IAYhB,OAhB0CzH,EAAA2H,EAAAX,GAStCtH,OAAAyB,eAAIwG,EAAAvH,UAAA,UAAO,KAAX,WACI,OAAOF,KAAK0H,0CAGhBlI,OAAAyB,eAAIwG,EAAAvH,UAAA,QAAK,KAAT,WACI,OAAOF,KAAKuH,wCAEpBE,GAhB0CL,YAsB1BO,EAAcC,GAC1B,OAAO9G,QAAQO,SAHS,gBAGqBuG,oBAGjD,SAAAC,KA8MA,OA7MWA,EAAAC,gBAAP,SACIhC,EACAzB,QAAA,IAAAA,IAAAA,EAAA,IAMAA,EAAU7E,OAAOuI,OAAO,CACpBC,kBAAmB,YACnBC,iBAAiB,GAClB5D,GAEH,IAAI6D,EAAe,GACf/D,EAAc,KAGlB,GAAI2B,aAAiBnG,MACjBuI,EAAU,IAAIT,EACV,QACAU,EAAUL,gBAAgBhC,EAAM,GAAIzB,SAIxC,IAAK,IAAI9D,KAAOuF,EACZ,GAA0B,mBAAfA,EAAMvF,GAAqB,CAClC,IAAI6H,EAAoB,GAGE,iBAAftC,EAAMvF,GACb6H,EAAeD,EAAUE,0BAA0BvC,EAAOvF,EAAK8D,GAGlC,mBAAfyB,EAAMvF,KACpB6H,EAAe,IAAId,EAAkBxB,EAAMvF,KAG3CO,QAAQwH,YA5CJ,gBA4CqCxC,EAAOvF,GAChDO,QAAQyH,YA7CJ,gBA8CqBzC,EAAOvF,EADhCO,CAGIgF,EAAOvF,EAAK6H,GAEqB,mBAAvB/D,EAAQmE,YACtBnE,EAAQmE,WAAW1C,EAAOvF,EAAK6H,GAInCF,EACIC,EAAUM,oBAAoBpE,EAAS9D,EAAKuF,IAC5CsC,EA2BhB,OAhBQjE,EALa,iBAAV2B,EAEDA,aAAiB4C,MAAW5C,aAAiBnG,MAGtCuI,EAFA,IAAIT,EAAqB,SAAUS,GAKvC,CAAEA,QAAOA,GAGlBpH,QAAQwH,YA1EQ,gBA0EyBxC,EAAM7F,aAC/Ca,QAAQyH,YA3EQ,gBA4ESzC,EAAM7F,YAD/Ba,CAGIgF,EAAM7F,YAAa,KAAMkE,GAEQ,mBAAvBE,EAAQmE,YACtBnE,EAAQmE,WAAW1C,EAAO,KAAM3B,GAG7BA,GAGJ0D,EAAAQ,0BAAP,SAAiCM,EAAapI,EAAK8D,GAC/C,IAAI+D,EAAe,KAGnB,GAAoB,OAAhBO,EAAOpI,GACP6H,EAAe,IAAId,EAAkB,WAGlC,GAAIqB,EAAOpI,aAAgBZ,MAAO,CACrC,IAAIW,EAASqI,EAAOpI,GAGhB6H,EADqB,iBAAd9H,EAAO,GACC,IAAImH,EAAqB,QAAS,IAAIH,EAAkBhH,EAAO,KAG/D6H,EAAUL,gBAAgBxH,EAAQ+D,QAKrD+D,EADOO,EAAOpI,aAAgBmI,KACf,IAAIjB,EAAqB,OAAQ,KAAMkB,EAAOpI,IAI9C4H,EAAUL,gBAAgBa,EAAOpI,GAAM8D,GAG1D,OAAO+D,GAGJP,EAAAY,oBAAP,SAA2BpE,EAAc9D,EAAKoI,GAC1C,IAAIC,EAAYrI,EAGhB,GAAI8D,EAAQ4D,iBAAqC,MAAlB1H,EAAIsI,OAAO,GAAY,CAClD,IAAIC,EAAavI,EAAIwI,OAAO,EAAGxI,EAAII,QAE/BmI,KAAcH,IACdC,EAAYE,GAUpB,MAJkC,eAA9BzE,EAAQ2D,oBACRY,EAAYT,EAAUa,yBAAyBJ,IAG5CA,GAIJf,EAAAoB,oBAAP,SAA2BhG,EAAWoB,GAClC,IAAIF,EAAS,KAMb,GALAE,EAAU7E,OAAOuI,OAAO,CACpBC,kBAAmB,YACnBC,iBAAiB,GAClB5D,GAECpB,aAAgBtD,MAChBwE,EAAS,GAETlB,EAAKiG,SAAQ,SAAUC,GACnBhF,EAAO9B,KAAK8F,EAAUc,oBAAoBE,EAAK9E,YAEhD,GAAoB,iBAATpB,EAGd,IAAK,IAAI1C,KAFT4D,EAAS,GAEOlB,EACZ,IAAKoB,EAAQ4D,iBAAqC,MAAlB1H,EAAIsI,OAAO,GAAY,CACnD,IAAIO,EAAW7I,EAEmB,eAA9B8D,EAAQ2D,oBACRoB,EAAWjB,EAAUa,yBAAyBzI,IAGzB,iBAAd0C,EAAK1C,GACZ4D,EAAOiF,GAAYjB,EAAUc,oBAAoBhG,EAAK1C,GAAM8D,GAE5DF,EAAOiF,GAAYnG,EAAK1C,GAMxC,OAAO4D,GAIJ0D,EAAAwB,oBAAP,SAA2BpG,EAAWqG,QAAA,IAAAA,IAAAA,EAAA,IAClC,IAAInF,EAAS,KAEb,GAAIlB,aAAgBtD,MAChBwE,EAAS,GAETlB,EAAKiG,SAAQ,SAAUC,GACnBhF,EAAO9B,KAAK8F,EAAUkB,oBAAoBF,YAE3C,GAAoB,iBAATlG,EAGd,IAAK,IAAI1C,KAFT4D,EAAS,GAEOlB,EACa,iBAAdA,EAAK1C,GACR0C,EAAK1C,aAAgBmI,KACrBvE,EAAO5D,GACH,SAAU+I,GACVA,EAAUC,gBAAgBC,SACtBF,EAAUC,KAAKtG,EAAK1C,IAAQ0C,EAAK1C,GAAKkJ,SAAS,KAEvDtF,EAAO5D,GAAO4H,EAAUkB,oBAAoBpG,EAAK1C,IAEzB,mBAAd0C,EAAK1C,KACnB4D,EAAO5D,GAAO0C,EAAK1C,IAK/B,OAAO4D,GAGJ0D,EAAAmB,yBAAP,SAAgClH,GAG9B,OAFiBA,EAAMqE,QAAQ,YAAa,OAAOD,eAIzD2B,KAEIM,EAAYN,EChOH6B,EAAmBjI,OAAO,kBC/B1BkI,EAAqBlI,OAAO,+BCD5BmI,EAAsBnI,OAAO,gCCQ7BoI,EAAqBpI,OAAO,4BCS5BqI,EAAsBrI,OAAO,kCCZtC,SAAYyD,GALZlF,KAAAwE,MAAQ,GACRxE,KAAAuF,QAAU,IAAIwE,EAAAA,YACd/J,KAAAiE,WAAa,WACbjE,KAAAqE,QAAU,GAGNrE,KAAKqE,QAAQhC,KAAK6C,IAeb8E,EAA+BvI,OAAO,yCCftCwI,EAA4BxI,OAAO,sCCHnCyI,EAAwBzI,OAAO,uCCE5B0I,EAAc7J,EAAQC,EAAK6J,GAClCA,EAASC,cACVD,EAASC,YAAc,GACvB,CACIX,EACAC,EACAC,EACAE,EACAE,EACAC,EACAJ,EACAK,GACFhB,SAAQ,SAACoB,GACP,IAAIC,EAAkB,CAACD,EAAYhK,GAE/BC,GACAgK,EAAgBlI,KAAK9B,GAIrBO,QAAQwH,YAAYvF,MAAMjC,QAASyJ,KAEnCH,EAASC,YAAc7K,OAAOuI,OAAO,GACjCqC,EAASC,YACTvJ,QAAQyH,YAAYxF,MAAMjC,QAASyJ,0BCrBvD,SAAAC,KAqYA,OApYWA,EAAAC,0BAAP,SACIC,EACA/B,EACAgC,EAIAtG,GAEA,YANA,IAAAsG,IAAAA,EAAA,WAIA,IAAAtG,IAAAA,EAAA,IAEOmG,EAAeI,8BAClBF,EAAavC,EAAUL,gBAAgBa,EAAQtE,GAAUsG,IAM1DH,EAAAK,cAAP,SAAqBtK,GACjB,IAAMuK,EAAWvK,EAAI4F,QAAQ,YAAa,OAAOA,QAAQ,KAAM,KAE/D,OAAO2E,EAASjC,OAAO,GAAGkC,cAAgBD,EAASE,MAAM,IAGtDR,EAAAI,8BAAP,SACIF,EACAO,EACAN,EACAO,QADA,IAAAP,IAAAA,EAAA,WACA,IAAAO,IAAAA,EAAA,MAEA,IAAI/G,EAAc,CACdgH,cAAe,GACfC,eAAgB,IAEdC,EAAqB,CAAC,QAAS,UAAUrH,QAAQiH,EAAuB5D,QAAU,EACpFiE,EAAcD,EAAqBJ,EAAuBvD,SAAWuD,EAEzE,IAAK,IAAI1K,KAAO+K,EAEZ,KAAI,CAAC,MAAMtH,QAAQzD,IAAQ,GAA3B,CAEA,IAAI6J,EAAW,KACXmB,EAAwB,KACxBC,EAAUF,EAAY/K,GAG1B,GAAI,CAAC,SAAU,SAASyD,QAAQwH,EAAQnE,QAAU,EAC9C,GAAsB,UAAlBmE,EAAQnE,MACR+C,EAAWI,EAAeiB,YAAYD,EAASjL,EAAKmK,OACjD,CAEH,IAAIgB,EAAQlB,EAAemB,oCAAoCH,EAASjL,EAAKmK,EAAjEF,GAEZJ,EAAW,CACPwB,UAAW,SACXrG,QAASmG,EAAMP,yBAAyBU,EAAAA,UACpCH,EAAMP,cAAgB,IAAIU,EAAAA,UAAUH,EAAMP,cAAeX,EAAesB,sBAAsBJ,GAAOK,YACzGC,SAAUN,EAAMN,qBAKvB,GAAsB,QAAlBI,EAAQnE,MACb,GAAgB,cAAZmE,QAAmD,IAAjBA,EAAQnE,MAAsB,CAC5D,IAAA4E,EAAAzB,EAAAsB,sBAAAN,GAAEO,EAAAE,EAAAF,WAAYG,EAAAD,EAAAC,cAElBX,EAAwB,CACpBjH,KAAMkH,EAAQnE,MACd9B,QAAS,IAAIwE,EAAAA,YAAYmC,EAAgBV,EAAQjE,OAAS,GAAIwE,SAGlE3B,EAAWc,EAAuBA,EAAqBM,EAASjL,GAAO,UAK3E6J,EAAWO,EAAiBA,EAAea,EAASjL,GAAO,KAI/D,IAAKgL,IAA0BnB,EAAU,CAC/B2B,EAAAvB,EAAAsB,sBAAAN,GAAAO,WAEN3B,EAAW,CACP9F,KAAM,SACNL,WAAY,OACZsB,QAAS,IAAIwE,EAAAA,YAAY,GAAIgC,IAKjC3B,IACAmB,EAAwBnB,GAG5BmB,EAAsB/G,MAAQgG,EAAeK,cAActK,GAC3DgL,EAAsB7F,SAAW8E,EAAe2B,kCAAkCZ,GAClFf,EAAe4B,4BACXZ,EAASD,GAGbpH,EAAOgH,cAAc5K,GAAOgL,EAAsBhG,QAClDpB,EAAOiH,eAAe7K,GAAOgL,EAcjC,OAXApH,EAAOiH,eAAe1F,SAAW8E,EAAe2B,kCAAkChI,EAAOiH,gBAErFC,IACAlH,EAAOiH,eAAiB,CACpBQ,UAAWX,EAAuB3G,KAClC0H,SAAU7H,EAAOiH,gBAGrBZ,EAAe6B,kBAAkBpB,EAAwB9G,EAAOiH,iBAG7DjH,GAGJqG,EAAAsB,sBAAP,SAA6BN,GACzB,IAAIO,EAAaP,EAAQnB,aAAemB,EAAQnB,YAAY0B,WAAaP,EAAQnB,YAAY0B,WAAa,GACtGG,GAA+D,IAA/C,MAACI,EAAW,MAAMtI,QAAQwH,EAAQjE,QAMtD,OAJAwE,EAAmC,mBAAfA,EAA4BA,EAAWvB,EAAe9F,aAAeqH,EAErFG,GAAuC,IAAtBH,EAAWpL,QAAcoL,EAAW1J,KAAKkK,EAAAA,WAAWC,UAElE,CAAET,WAAUA,EAAEG,cAAaA,IAGvB1B,EAAAmB,oCAAf,SACIc,EACAlM,EACAmK,EACAgC,QAAA,IAAAA,IAAAA,GAAA,GAyEA,OAvEe,WACX,IAAIlB,EAAU,KAcVmB,EAAa,KAEjB,GACI,SAbAnB,EAFAkB,EAEU,IAAIjF,EACV,QACAU,EAAUL,gBACN,IAAI2E,IAIFA,GAMQ/E,UAClB,CACI,MACA,SACA,UACA,SACA,OACA,IACF1D,QAAQwH,EAAQ9D,SAASpD,OAAS,EACtC,CAEE,IAAIiB,EAAU,IAAIwE,EAAAA,YACd,UAAWyB,EAAQ9D,SAAW8D,EAAQ9D,SAAS5F,MAAQ,GACvD,CAACyK,EAAAA,WAAWC,WACbpB,EAAiB,GAEpBA,EAAe7K,GAAO,CAClBiE,MAAOgG,EAAeK,cAActK,GACpC+D,KAAMkH,EAAQ9D,SAASpD,KACvBiB,QAAOA,GAGXoH,EAAa,CACTxB,cAAe5F,EACf6F,eAAcA,GAGlBZ,EAAe4B,4BACXZ,EAAQ9D,SAAU0D,EAAe7K,SAIrCoM,EAAanC,EAAeI,8BAA8BF,EAAac,EAAQ9D,UAWnF,OARAiF,EAAWvB,eAAe1F,SAAW8E,EAAe2B,kCAAkCQ,EAAWvB,gBAE7F,gBAAiBI,GAAmD,mBAAjCA,EAAQnB,YAAYuC,UACvDpB,EAAQnB,YAAYuC,SAChBD,EAAWvB,eAAgBZ,EAAe9F,aAI3C,CACHyG,cACIwB,EAAWxB,yBAAyBpB,EAAAA,aAAgC,WAAjByB,EAAQlH,KACvDqI,EAAWxB,cAEX,IAAIU,EAAAA,UAAUc,EAAWxB,cAAeX,EAAesB,sBAAsBa,GAAYZ,YACjGX,eAAgBuB,EAAWvB,kBAOxBZ,EAAAiB,YAAf,SAA2BD,EAAcjL,EAAamK,GAClD,IAAImC,EAAqB,IAAIC,EAAAA,UAAU,GAAItC,EAAesB,sBAAsBN,GAASO,YACrFgB,EAAe,GAGf5I,EAAS,CACTyH,UAAW,QACXzE,UACIqE,EAAQnB,aAAemB,EAAQnB,YAAYlD,UALnC,KAOJ,SAAUqE,EAAQ9D,SACd,YAAc,SAE1BnC,QAASsH,EACTb,SAAU,GACVgB,mBAAmB,GACnBC,UAAW,EACXxH,IAAK,KACLE,OAAQ,MAGZ,GAAI6F,EAAQnB,aAAemB,EAAQnB,YAAY6C,kBAAmB,CAC9D,IAAIC,EAAI,EACR3B,EAAQnB,YAAY6C,kBAAkBhE,SAAQ,SAAUkE,GACpDL,EAAaI,GAAK3C,EAAemB,oCAAoCyB,EAAKC,UAAW,GAAI3C,GAAa,GACtGvG,EAAO6I,mBAAmBG,GAAKC,EAAK5I,MACpC2I,GAAK,UAGTJ,EAAa,GAAKvC,EAAemB,oCAAoCH,EAASjL,EAAKmK,GA6BvF,OALAvG,EAAOsB,IArBG,WACF,IAAI6H,EAAcP,EAAa5I,EAAO8I,aAEXJ,EACnBxK,KAAKiL,EAAYnC,eACzBhH,EAAO6H,SAAS3J,KAAKiL,EAAYlC,gBAEjCkC,EAAYlC,eAAemC,uBAAyBpJ,EAAO6I,mBAAmB7I,EAAO8I,WAEjF,gBAAiBzB,GAAiD,mBAA/BA,EAAQnB,YAAYmD,QACvDhC,EAAQnB,YAAYmD,OAChBF,EAAYlC,eAAgBZ,EAAe9F,cAW3DP,EAAOwB,OAPM,SAAU3E,GACY6L,EACnBY,SAASzM,GACjBmD,EAAO6H,SAAS0B,OAAO1M,EAAG,IAQ3BmD,GAGJqG,EAAA2B,kCAAP,SAAyCzI,GAqErC,OApEe,SAAUiK,oBAEjB,IAAIC,EAAiBlK,EAAekI,UAAYlI,EAAesI,SAAWtI,EAE1E,GAAInD,KAAOqN,EACP,GAAIA,EAAerN,GAAK+D,KACQ,iBAAjBqJ,EAASpN,IAEZ,mBAAoBqN,EAAerN,IAEnCqN,EAAerN,GAAKsN,eAAeD,EAAerN,GAAMoN,GAG5DC,EAAerN,GAAKgF,QAAQG,SAExBiI,EAASpN,IAIT,kBAAmBqN,EAAerN,IAElCqN,EAAerN,GAAKuN,cAAcF,EAAerN,GAAMoN,SAE5B,IAAjBA,EAASpN,IAAuBoN,EAASpN,QAM3D,GAAsC,WAAlCqN,EAAerN,GAAKqL,UAEpBgC,EAAerN,GAAKmF,SAASiI,EAASpN,QACnC,CAEH,IAAKoN,EAASpN,oBAId,KAAOqN,EAAerN,GAAKgF,QAAQC,SAAS7E,OAAS,GACjDiN,EAAerN,GAAKoF,OAAO,GAG/B,IAAIoI,EAAI,EAERJ,EAASpN,GAAK2I,SAAQ,SAAUkE,GAExB,qCAAsCQ,EAAerN,KAErDqN,EAAerN,GAAK0M,UAAYW,EAAerN,GAAKyN,iCAAiCZ,IAGzFQ,EAAerN,GAAKkF,MAEpB,IAAIwI,EAAuB,GAC3BA,EAAqB1N,GAAO6M,EAE5BQ,EAAerN,GAAKyL,SAAS+B,GAAGrI,SACM,WAAlCkI,EAAerN,GAAK4G,UAAyB8G,EAAuBb,GAGxEW,SA3DpB,IAAK,IAAIxN,KAAOoN,QAsEjBnD,EAAA4B,4BAAP,SAAmCd,EAAa4C,GACnB,YAArB5C,EAAYhH,KACZ4J,EAAYjK,WAAaqH,EAAY6C,cAAgB,QAAU,WACxD7C,EAAYjH,QACfiH,EAAYjH,QAAQ1D,OAAS,GAAK2K,EAAY8C,WAC9CF,EAAYjK,WAAaqH,EAAY6C,cACP,GAA1B7C,EAAY8C,WACR,QAAU,WACd,SAEJF,EAAYjK,WAAaqH,EAAY6C,cAAgB,QAAU,YAGnED,EAAYjK,WAAaqH,EAAYhH,KACZ,WAArB4J,EAAY5J,OAAmB4J,EAAYjK,WAAa,SAGhEuG,EAAe6B,kBAAkBf,EAAa4C,IAI3C1D,EAAA6B,kBAAP,SAAyBf,EAAa4C,GAClC,CACI,QACA,OACA,eACA,iBACA,gBACA,mCACA,aACA,gBACA,UACA,QACA,OACA,OACA,aACA,YACA,eACA,YACFhF,SAAQ,SAAUkE,GACZ9B,EAAYjB,aAAe+C,KAAQ9B,EAAYjB,cAC/C6D,EAAYd,GAAQ9B,EAAYjB,YAAY+C,OAIpDc,EAAYxJ,YAAc8F,EAAe9F,aApXtC8F,EAAA9F,YAAc,IAAI2J,IAsX7B7D,kBC9YA,SAAA8D,KAYA,OAXIA,EAAApO,UAAAqO,UAAA,SAAU5F,WACFxE,EAAS,OAEb,IAAgB,IAAAqK,EAAAlN,EAAA9B,OAAOiP,KAAK9F,IAAO+F,EAAAF,EAAA3M,QAAA6M,EAAA3M,KAAA2M,EAAAF,EAAA3M,OAAE,CAAhC,IAAItB,EAAGmO,EAAA5M,MACJ6G,EAAO9I,eAAeU,IACtB4D,EAAO9B,KAAK,CAAC9B,IAAGA,EAAEwE,IAAK4D,EAAOpI,uGAItC,OAAO4D,GAVFmK,EAAalO,EAAA,CAHzBuO,EAAAA,KAAK,CACFpK,KAAM,mBAEG+J,MCuBPM,EAAqB,CACvB/H,EACAE,EACAC,EACAC,EACAxE,EACAyE,EACAoH,gBAuCJ,SAAAO,KACA,OADaA,EAAYzO,EAAA,CApCxB0O,EAAAA,SAAS,CACNC,QAAS,CACLC,EAAAA,YACAC,EAAAA,oBAGAC,EAAAA,wBACAC,EAAAA,sBACAC,EAAAA,gBACAC,EAAAA,sBACAC,EAAAA,cACAC,EAAAA,kBACAC,EAAAA,oBACAC,EAAAA,mBACAC,EAAAA,eACAC,EAAAA,oBACAC,EAAAA,eACAC,EAAAA,iBAEJC,aAAclB,EACdmB,QAAOxN,EAAA,CACH2M,EAAAA,wBACAC,EAAAA,sBACAC,EAAAA,gBACAC,EAAAA,sBACAC,EAAAA,cACAC,EAAAA,kBACAC,EAAAA,oBACAC,EAAAA,mBACAC,EAAAA,eACAC,EAAAA,oBACAC,EAAAA,eACAC,EAAAA,iBACGjB,MAGEC,8BVjEgBxK,GACzB,OAAOvD,QAAQO,SACXsI,EACAnK,OAAOuI,OACsB,GACtB1D,2DEEqBA,GAChC,OAAOvD,QAAQO,SACXwI,EAAoB,CAChBmG,aAAcxQ,OAAOuI,OACK,GACnB1D,sDCIWA,GAC1B,OAAOvD,QAAQO,SACXyI,EACAtK,OAAOuI,OAAO,CACNqG,WAAY,GAEU,CACtBnK,WAAY,UACbI,4DEnBqBA,GAChC,OAAOvD,QAAQO,SACX4I,EACAzK,OAAOuI,OACH,CACIoG,eAAe,GAChB9J,EAAS,CACR8C,UAAW,iENmBA9C,GACvB,IAAI4L,EAAO,KASX,OAPI5L,EAAQG,QACRyL,EAAO5L,EAAQG,MAAM0B,cAChBC,QAAQ,YAAa,IACrBA,QAAQ,WAAY,KACpBA,QAAQ,WAAY,KAGtBrF,QAAQO,SAASqI,EACpBlK,OAAOuI,OAAO,CACVmI,aAAa,EACbD,KAAIA,GACL5L,2PO3CqBA,GAC5B,OAAOvD,QAAQO,SACX6I,EACA1K,OAAOuI,OACyB,GACzB1D,iEFawBA,GACnC,OAAOvD,QAAQO,SACX2I,EACAxK,OAAOuI,OAAO,CACNZ,UAAW,QAEoB,CAC/BiH,WAAY,MACb/J,4IH7BeA,GAC1B,OAAOvD,QAAQO,SACXuI,EACApK,OAAOuI,OACuB,GACvB1D,gHM8BX,OAAOsD,EAAcwC","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {\n    Component,\n    OnInit,\n    ComponentFactoryResolver,\n    ViewChild,\n    ViewContainerRef\n} from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport { IMultipleChoicesOptionsFormConfig } from \"../class/decorators/MultipleChoicesOptions\";\nimport { IBaseFormConfig } from \"../class/decorators/FormConfig\";\nimport { IArrayOptionsFormConfig } from \"../class/decorators/ArrayOptions\";\nimport { IObjectOptionsFormConfig } from \"../class/decorators/ObjectOptions\";\nimport { IChoiceOptionsFormConfig } from \"../class/decorators/ChoiceOptions\";\n\n@Component({\n    selector: 'hb-form-widget',\n    templateUrl: './hb-form-widget.tpl.html',\n    inputs: ['data', 'key', 'parent']\n})\nexport class HbFormWidgetComponent implements OnInit {\n    public resolvedOptions;\n    public key;\n    public data: any & IBaseFormConfig & IMultipleChoicesOptionsFormConfig & IArrayOptionsFormConfig & IObjectOptionsFormConfig & IChoiceOptionsFormConfig;\n    public parent;\n    static slugMap = [];\n\n    @ViewChild(\"customBlock\", { read: ViewContainerRef, static: true }) customBlock;\n\n    constructor(\n        private resolver: ComponentFactoryResolver\n    ) {\n    }\n\n    log(...args) {\n        console.log(...args);\n    }\n\n    ngAfterViewInit() {\n        if (!this.data.hide && this.data.useComponent) {\n            const factory = this.resolver.resolveComponentFactory(\n                this.data.useComponent\n            );\n            const ref = this.customBlock.createComponent(factory);\n            ref.instance.templateObject = this.data;\n            ref.instance.parentTemplateObject = this.parent;\n\n            ref.changeDetectorRef.detectChanges();\n        }\n    }\n\n    isOptionSelectingComponent() {\n        return ['radio', 'checkbox', 'select'].indexOf(this.data.renderType) > -1;\n    }\n\n    ngOnInit() {\n        if (this.isOptionSelectingComponent()) {\n            let data = this.data;\n\n            let result = null;\n            let resolved = null;\n\n            let options: any = [];\n            if (\n                data.options && (\n                    data.options.length ||\n                    typeof data.options === 'function'\n                )\n            ) {\n                options = data.options\n            } else if (\n                data.type === 'boolean' &&\n                data.renderType === 'checkbox'\n            ) {\n                options = [{\n                    name: data.label,\n                    value: true,\n                }];\n            }\n\n            if (options.length === 0) {\n                throw new Error('No options set for ' + data.key + ' in ' + this.parent.key);\n            }\n\n            if (typeof options === 'function') {\n                resolved = options(data.diContainer, this.data, this.parent);\n            } else if (!(result instanceof Observable)) {\n                resolved = options;\n            }\n\n            result = resolved;\n\n            if (!(resolved instanceof Observable)) {\n                result = new Observable((o) => {\n                    o.next(resolved);\n                    o.complete();\n                });\n            }\n\n            this.resolvedOptions = result;\n        }\n    }\n\n    stringToBoolean(val) {\n        return val === 'true'\n    }\n\n    updateParentValue($event, option) {\n        const target = $event.target ? $event.target : $event.source;\n        let isChecked = target.checked;\n\n        switch (this.data.renderType) {\n            case 'checkbox':\n                let parentControls = this.parent.control.controls;\n\n                if (isChecked) {\n                    this.parent.add();\n\n                    parentControls[parentControls.length - 1].setValue(option.value);\n                } else {\n                    let i = 0;\n\n                    for (; i < parentControls.length; i++) {\n                        if (parentControls[i].value == option.value) break;\n                    }\n\n                    this.parent.remove(i);\n                }\n\n                break;\n\n            case 'radio':\n                if (isChecked) this.data.control.patchValue(target.value);\n\n                break;\n        }\n    }\n\n    typeof(input) {\n        return typeof input;\n    }\n\n    slugifyString(input: string) {\n        if (input in HbFormWidgetComponent.slugMap) {\n            return HbFormWidgetComponent.slugMap[input];\n        }\n\n        if (input) {\n            return HbFormWidgetComponent.slugMap[input] = input\n                .toLowerCase()\n                .replace(/[^\\w\\s-]/g, '')\n                .replace(/[\\s_-]+/g, '-')\n                .replace(/^-+|-+$/g, '');\n        } else {\n            throw new Error('Cannot slugify input, input is undefined.')\n        }\n    }\n}\n","import { Component } from \"@angular/core\";\nimport { HbFormWidgetComponent } from './hb-form-widget.component';\n\n@Component({\n    selector: 'hb-form-array',\n    templateUrl: './hb-form-array.tpl.html',\n    inputs: ['key', 'data', 'parent']\n})\nexport class HbFormArrayComponent extends HbFormWidgetComponent {\n}\n","import { Component } from \"@angular/core\";\nimport { HbFormArrayComponent } from \"./hb-form-array.component\";\n\n@Component({\n    selector: 'hb-mat-form-array',\n    templateUrl: './hb-form-mat-array.tpl.html',\n    inputs: ['key', 'data', 'parent']\n})\nexport class HbFormMatArrayComponent extends HbFormArrayComponent {\n}\n","import { Component } from \"@angular/core\";\nimport { HbFormWidgetComponent } from './hb-form-widget.component';\n\n@Component({\n    selector: 'hb-form-object',\n    templateUrl:  './hb-form-object.tpl.html',\n    inputs: ['id', 'key', 'data', 'parent']\n})\nexport class HbFormObjectComponent extends HbFormWidgetComponent {\n}\n","import { Component } from \"@angular/core\";\nimport { HbFormObjectComponent } from \"./hb-form-object.component\";\n\n@Component({\n    selector: 'hb-mat-form-object',\n    templateUrl:  './hb-form-mat-object.tpl.html',\n    inputs: ['id', 'key', 'data', 'parent']\n})\nexport class HbFormMatObjectComponent extends HbFormObjectComponent {\n}\n","import { HbFormWidgetComponent } from \"./hb-form-widget.component\";\nimport { Component, OnInit } from \"@angular/core\";\n\n@Component({\n    selector: 'hb-mat-form-widget',\n    templateUrl: './hb-form-mat-widget.tpl.html',\n    inputs: ['data', 'key', 'parent']\n})\nexport class HbFormMatWidgetComponent extends HbFormWidgetComponent implements OnInit {\n    ngOnInit() {\n        super.ngOnInit();\n\n        if (\n            this.parent.arrayType == 'enum' &&\n            this.parent.control.value.indexOf(this.data.options[0].value) > -1\n        ) {\n            this.data.control.setValue(\n                this.data.options[0].value\n            )\n        }\n    }\n}\n","export type AttributeType = 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object' | 'any';\n\nexport class TypeMeta {\n    constructor(protected _type: AttributeType) {}\n\n    get type(): AttributeType {\n        return this._type;\n    }\n}\n\nexport class PrimitiveTypeMeta extends TypeMeta {\n    constructor(\n        protected _value: any\n    ) {\n        super(\n            <AttributeType>([\n                'string',\n                'number',\n                'boolean'\n            ].indexOf(typeof _value) > -1 ? typeof _value : 'any')\n        );\n    }\n\n    get value(): any {\n        return this._value;\n    }\n}\n\nexport class NonPrimitiveTypeMeta extends TypeMeta {\n    constructor(\n        type: 'object' | 'array' | 'date',\n        private _mapping: any = null, // All attributes should be type of ExtractorResultType\n        private _value: any = null\n    ) {\n        super(type);\n    }\n\n    get mapping(): ExtractorResultType {\n        return this._mapping;\n    }\n\n    get value(): any {\n        return this._value;\n    }\n}\n\nexport type ExtractorResultType = NonPrimitiveTypeMeta | PrimitiveTypeMeta;\n\nconst OnOATResolvedSymbol = 'OnOATResolved';\n\nexport function OnOATResolved(cb: (target: any, key: string, resolved: any) => void) {\n    return Reflect.metadata(OnOATResolvedSymbol, cb);\n}\n\nexport class ObjectAttributeTypeExtractor {\n    static generateMapping(\n        input: any,\n        options: {\n            keyNamingStrategy?: 'camelCase' | 'snake_case',\n            stripUnderscore?: boolean,\n            onResolved?: (target: any, key?: string, resolved?: any) => void\n        } = {}\n    ): any {\n        options = Object.assign({\n            keyNamingStrategy: 'camelCase',\n            stripUnderscore: false\n        }, options);\n\n        let mapping: any = {};\n        let result: any = null;\n\n        // input is an array, analyze the first cell only\n        if (input instanceof Array) {\n            mapping = new NonPrimitiveTypeMeta(\n                'array',\n                Extractor.generateMapping(input[0], options)\n            );\n        } else {\n            // Analyze attributes inside input object\n            for (let key in input) {\n                if (typeof input[key] !== 'function') {\n                    let resolvedMeta: any = {};\n\n                    // Array or Object\n                    if (typeof input[key] === 'object') {\n                        resolvedMeta = Extractor.generateObjectTypeMapping(input, key, options);\n\n                    // Any primitive type\n                    } else if (typeof input[key] !== 'function') {\n                        resolvedMeta = new PrimitiveTypeMeta(input[key]);\n                    }\n\n                    if (Reflect.hasMetadata(OnOATResolvedSymbol, input, key)) {\n                        Reflect.getMetadata(\n                            OnOATResolvedSymbol, input, key\n                        )(\n                            input, key, resolvedMeta\n                        );\n                    } else if (typeof options.onResolved === 'function') {\n                        options.onResolved(input, key, resolvedMeta);\n                    }\n\n                    // Finished, set resolved attribute metadata to result\n                    mapping[\n                        Extractor.resolveAttributeKey(options, key, input)\n                    ] = resolvedMeta;\n                }\n            }\n        }\n\n        if (\n            typeof input === 'object'\n        ) {\n            if (!(input instanceof Date) && !(input instanceof Array)) {\n                result = new NonPrimitiveTypeMeta('object', mapping);\n            } else {\n                result = mapping;\n            }\n        } else {\n            result = { mapping };\n        }\n\n        if (Reflect.hasMetadata(OnOATResolvedSymbol, input.constructor)) {\n            Reflect.getMetadata(\n                OnOATResolvedSymbol, input.constructor\n            )(\n                input.constructor, null, result\n            );\n        } else if (typeof options.onResolved === 'function') {\n            options.onResolved(input, null, result);\n        }\n\n        return result\n    }\n\n    static generateObjectTypeMapping(object: any, key, options: any) {\n        let resolvedMeta = null;\n\n        // Mark type as any if value is null\n        if (object[key] === null) {\n            resolvedMeta = new PrimitiveTypeMeta(null);\n\n        // For Array\n        } else if (object[key] instanceof Array) {\n            let target = object[key];\n            // For Primitive Array\n            if (typeof target[0] !== 'object') {\n                resolvedMeta = new NonPrimitiveTypeMeta('array', new PrimitiveTypeMeta(target[0]));\n            // For Object Array\n            } else {\n                resolvedMeta = Extractor.generateMapping(target, options);\n            }\n\n        // For Date\n        } else if (object[key] instanceof Date) {\n            resolvedMeta = new NonPrimitiveTypeMeta('date', null, object[key]);\n\n        // For Object\n        } else {\n            resolvedMeta = Extractor.generateMapping(object[key], options);\n        }\n\n        return resolvedMeta;\n    }\n\n    static resolveAttributeKey(options: any, key, object: any) {\n        let setterKey = key;\n\n        // if set function exists, rename _attr to attr\n        if (options.stripUnderscore && key.charAt(0) === '_') {\n            let trimmedKey = key.substr(1, key.length);\n\n            if (trimmedKey in object) {\n                setterKey = trimmedKey;\n            }\n        }\n\n        // Some serializer serialize data with snake_case\n        // but JS Entity Classes name attributes with camelCase\n        if (options.keyNamingStrategy === 'snake_case') {\n            setterKey = Extractor.convertStringToSnakeCase(setterKey);\n        }\n\n        return setterKey;\n    }\n\n    // For naming convention changing. Not really related to this extractor\n    static fixNamingConvention(data: any, options: any) {\n        let result = null;\n        options = Object.assign({\n            keyNamingStrategy: 'camelCase',\n            stripUnderscore: false\n        }, options);\n\n        if (data instanceof Array) {\n            result = [];\n\n            data.forEach(function (obj) {\n                result.push(Extractor.fixNamingConvention(obj, options));\n            });\n        } else if (typeof data === 'object') {\n            result = {};\n\n            for (let key in data) {\n                if (!options.stripUnderscore || key.charAt(0) !== '_') {\n                    let finalKey = key;\n\n                    if (options.keyNamingStrategy === 'snake_case') {\n                        finalKey = Extractor.convertStringToSnakeCase(key);\n                    }\n\n                    if (typeof data[key] === 'object') {\n                        result[finalKey] = Extractor.fixNamingConvention(data[key], options);\n                    } else {\n                        result[finalKey] = data[key];\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // For JSON editor only. Should be extracted.\n    static convertDataToString(data: any, callbacks: any = {}) {\n        let result = null;\n\n        if (data instanceof Array) {\n            result = [];\n\n            data.forEach(function (obj) {\n                result.push(Extractor.convertDataToString(obj));\n            });\n        } else if (typeof data === 'object') {\n            result = {};\n\n            for (let key in data) {\n                if (typeof data[key] === 'object') {\n                    if (data[key] instanceof Date) {\n                        result[key] =\n                            'date' in callbacks &&\n                            callbacks.date instanceof Function ?\n                                callbacks.date(data[key]) : data[key].yyyymmdd('-');\n                    } else {\n                        result[key] = Extractor.convertDataToString(data[key]);\n                    }\n                } else if (typeof data[key] !== 'function') {\n                    result[key] = data[key];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    static convertStringToSnakeCase(value) {\n        const result = value.replace(/([A-Z]+)/g, \"_$1\").toLowerCase();\n\n      return result;\n    }\n}\n\nlet Extractor = ObjectAttributeTypeExtractor;\n","import { ICustomComponentConstructor } from \"../../HbFormModule\";\nimport { ValidatorFn } from \"@angular/forms\";\n\nexport type RenderType = 'text' | 'email' | 'number' | 'hidden' | 'radio' | 'checkbox' | 'textarea' | 'select';\nexport type HtmlElementAttribute = 'label' | 'input' | 'inputContainer' | 'widgetContainer';\n\ntype ObjectHtmlElementAttribute = 'objectHeaderContainer' | 'objectHeader' | HtmlElementAttribute;\ntype ArrayHtmlElementAttribute = 'arrayHeaderContainer' | 'arrayHeader' | HtmlElementAttribute;\n\nexport interface IBaseFormConfig {\n    label?: string;\n    defaultValue?: any;\n    hints?: string | { (diContainer: Map<string, any>, currentTemplateObject, parentTemplateObject): string };\n    validators?: Array<ValidatorFn> | { (diContainer: Map<string, any>, currentTemplateObject, parentTemplateObject): Array<ValidatorFn> };\n    useValidators?: Array<string>;\n    renderType?: RenderType;\n    hide?: boolean;\n    hideHeader?: boolean;\n    useComponent?: ICustomComponentConstructor;\n    html?: {\n        id?: {\n            [key in HtmlElementAttribute]: string\n        },\n        class?: {\n            [key in HtmlElementAttribute]: string\n        },\n        textarea?: {\n            row?: number\n        }\n    };\n    beforeSetValue?: {\n        (currentTemplateObject, rawValue): void\n    };\n    afterSetValue?: {\n        (currentTemplateObject, rawValue): void\n    };\n}\n\nexport const FormConfigSymbol = Symbol('FormConfig');\n\nexport function FormConfig(options: IBaseFormConfig) {\n    let slug = null;\n\n    if (options.label) {\n        slug = options.label.toLowerCase()\n            .replace(/[^\\w\\s-]/g, '')\n            .replace(/[\\s_-]+/g, '-')\n            .replace(/^-+|-+$/g, '');\n    }\n\n    return Reflect.metadata(FormConfigSymbol,\n        Object.assign({\n            hiderHeader: false,\n            slug,\n        }, options)\n    );\n}\n","import { IBaseFormConfig } from './FormConfig';\n\nexport interface IArrayOptionsFormConfig extends IBaseFormConfig {\n    onPush?: (childrenTemplate: any, diContainer: Map<string, any>) => void\n    arrayType?: 'object' | 'primitive' | 'enum'\n}\n\nexport const ArrayOptionsSymbol = Symbol('IArrayOptionsFormConfig');\n\nexport function ArrayOptions(options: IArrayOptionsFormConfig) {\n    return Reflect.metadata(\n        ArrayOptionsSymbol,\n        Object.assign(\n            <IArrayOptionsFormConfig>{\n            }, options\n        )\n    );\n}\n","import { IBaseFormConfig } from './FormConfig';\n\nexport interface IObjectOptionsFormConfig extends IBaseFormConfig {\n    onCreate: (childrenTemplate: any, diContainer: Map<string, any>) => void\n}\n\nexport const ObjectOptionsSymbol = Symbol('IObjectOptionsFormConfig');\n\nexport function ObjectOptions(options: IObjectOptionsFormConfig) {\n    return Reflect.metadata(\n        ObjectOptionsSymbol,\n        Object.assign(\n            <IObjectOptionsFormConfig>{\n            }, options\n        )\n    );\n}\n","import { Observable } from \"rxjs\";\n\nexport interface IAutocompleteOptions {\n    onInit?: (childrenTemplate: any, diContainer: Map<string, any>) => void;\n\n    // No being used yet\n    options?: Observable<\n        Array<{\n            label:string,\n            value: any\n        }>\n    >\n}\n\nexport const AutocompleteSymbol = Symbol('IAutocompleteOptions');\n\nexport function AutocompleteOptions(options: IAutocompleteOptions) {\n    return Reflect.metadata(\n        AutocompleteSymbol, {\n            autocomplete: Object.assign(\n                <IAutocompleteOptions>{\n                }, options\n            )\n        }\n    );\n}\n","import { IBaseFormConfig } from './FormConfig';\nimport { Observable } from \"rxjs\";\n\nexport interface IChoice {\n    name: string;\n    value: any;\n}\n\n/**\n *  For Form field accepts one value only out of multiple available options\n */\nexport interface IChoiceOptionsFormConfig extends IBaseFormConfig {\n    // checkbox is for boolean only\n    renderType?: 'radio' | 'select' | 'checkbox';\n    options: {\n        (\n            diContainer: Map<string, any>,\n            currentTemplateObject,\n            parentTemplateObject\n        ): Array<IChoice> | Observable<Array<IChoice>>\n    } | Array<IChoice> | Observable<Array<IChoice>>;\n}\n\nexport const ChoiceOptionsSymbol = Symbol('IChoiceOptionsFormConfig');\n\nexport function ChoiceOptions(options: IChoiceOptionsFormConfig) {\n    return Reflect.metadata(\n        ChoiceOptionsSymbol,\n        Object.assign({\n                maxChoices: 1\n            },\n            <IChoiceOptionsFormConfig>{\n                renderType: 'select'\n            }, options\n        )\n    );\n}\n","import { IBaseFormConfig } from './FormConfig';\nimport { Observable } from \"rxjs\";\nimport { FormControl } from \"@angular/forms\";\nimport { IChoice } from \"./ChoiceOptions\";\n\nexport class OptionWrapper {\n    label = '';\n    control = new FormControl();\n    renderType = 'checkbox';\n    options = [];\n\n    constructor(option: IChoice) {\n        this.options.push(option);\n    }\n}\n\nexport interface IMultipleChoicesOptionsFormConfig extends IBaseFormConfig {\n    maxChoices?: number;\n    options: {\n        (\n            diContainer: Map<string, any>,\n            currentTemplateObject,\n            parentTemplateObject\n        ): Array<OptionWrapper> | Observable<Array<OptionWrapper>>\n    } | Array<OptionWrapper> | Observable<Array<OptionWrapper>>;\n}\n\nexport const MultipleChoicesOptionsSymbol = Symbol('IMultipleChoicesOptionsFormConfig');\n\nexport function MultipleChoicesOptions(options: IMultipleChoicesOptionsFormConfig) {\n    return Reflect.metadata(\n        MultipleChoicesOptionsSymbol,\n        Object.assign({\n                arrayType: 'enum'\n            },\n            <IMultipleChoicesOptionsFormConfig>{\n                maxChoices: null,\n            }, options\n        )\n    );\n}\n","import { IBaseFormConfig } from \"./FormConfig\";\n\nexport interface IFlexibleObjectArrayFormConfig extends IBaseFormConfig {\n    objectDefinitions: Array<{\n        label: string,\n        structure: any // The class with decorator or data object\n    }>,\n    expandOptions?: boolean\n    // You need to specific which object definition you want to use for each value\n    resolveFlexibleObjectArrayConfig: (template: any, rawValue) => void\n}\n\nexport const FlexibleObjectArraySymbol = Symbol('IFlexibleObjectArrayFormConfig');\n\nexport function FlexibleObjectArray(options: IFlexibleObjectArrayFormConfig) {\n    return Reflect.metadata(\n        FlexibleObjectArraySymbol,\n        Object.assign(\n            {\n                expandOptions: false,\n            }, options, {\n                arrayType: 'object',\n            }\n        )\n    );\n}\n","import { IBaseFormConfig } from './FormConfig';\n\nexport interface IMatExtraOptionsFormConfig extends IBaseFormConfig {\n    matExtra: {\n        matPrefix?: string,\n        matSuffix?: string,\n    }\n}\n\nexport const MatExtraOptionsSymbol = Symbol('IMatExtraOptionsFormConfig');\n\nexport function MatExtraOptions(options: IMatExtraOptionsFormConfig) {\n    return Reflect.metadata(\n        MatExtraOptionsSymbol,\n        Object.assign(\n            <IMatExtraOptionsFormConfig>{\n            }, options\n        )\n    );\n}\n","import { OnOATResolved } from \"../ObjectAttributeTypeExtractor\";\n\nimport { FormConfigSymbol } from './decorators/FormConfig';\nimport { ArrayOptionsSymbol } from './decorators/ArrayOptions';\nimport { ObjectOptionsSymbol } from './decorators/ObjectOptions';\nimport { AutocompleteSymbol } from './decorators/AutocompleteOptions';\nimport { ChoiceOptionsSymbol } from './decorators/ChoiceOptions';\nimport { MultipleChoicesOptionsSymbol } from './decorators/MultipleChoicesOptions';\nimport { FlexibleObjectArraySymbol } from \"./decorators/FlexibleObjectArray\";\nimport { MatExtraOptionsSymbol } from \"./decorators/MatExtraOptions\";\n\nexport function onOATResolved(target, key, resolved) {\n    if (!resolved.formFactory) {\n        resolved.formFactory = {};\n        [\n            FormConfigSymbol,\n            ArrayOptionsSymbol,\n            ObjectOptionsSymbol,\n            ChoiceOptionsSymbol,\n            MultipleChoicesOptionsSymbol,\n            FlexibleObjectArraySymbol,\n            AutocompleteSymbol,\n            MatExtraOptionsSymbol\n        ].forEach((eachSymbol) => {\n            let getMetadataArgs = [eachSymbol, target];\n\n            if (key) {\n                getMetadataArgs.push(key);\n            }\n\n            if (\n                Reflect.hasMetadata.apply(Reflect, getMetadataArgs)\n            ) {\n                resolved.formFactory = Object.assign({},\n                    resolved.formFactory,\n                    Reflect.getMetadata.apply(Reflect, getMetadataArgs)\n                );\n            }\n        });\n    }\n}\n\nexport function SetupConfig() {\n    return OnOATResolved(onOATResolved);\n}\n","import {\n    FormBuilder,\n    FormGroup,\n    FormControl,\n    FormArray,\n    Validators,\n} from '@angular/forms';\nimport {\n    NonPrimitiveTypeMeta,\n    ObjectAttributeTypeExtractor as Extractor\n} from \"../ObjectAttributeTypeExtractor\";\n\nexport * from './NgFormFactoryDecorators';\n\nexport class Ng2FormFactory {\n    static generateFormGroupByObject(\n        formBuilder: FormBuilder,\n        object: any,\n        resolveTypeAny: () => {\n            ngFormControl: any,\n            templateConfig: any\n        } = null,\n        options: any = {}\n    ) {\n        return Ng2FormFactory.generateFormGroupByOATMapping(\n            formBuilder, Extractor.generateMapping(object, options), resolveTypeAny\n        );\n    }\n\n    static diContainer = new Map();\n\n    static generateLabel(key) {\n        const fixedKey = key.replace(/([A-Z]+)/g, \" $1\").replace(/_/g, ' ');\n\n        return fixedKey.charAt(0).toUpperCase() + fixedKey.slice(1);\n    }\n\n    static generateFormGroupByOATMapping(\n        formBuilder: FormBuilder,\n        attributeMappingObject: any, // Yet all attributes inside should be typeof ExtractorResultType\n        resolveTypeAny: (attrMapping, key: string) => { ngFormControl: any, templateConfig: any } = null,\n        resolveTypeUndefined: (attrMapping, key: string) => { ngFormControl: any, templateConfig: any } = null\n    ) {\n        let result: any = {\n            ngFormControl: {},\n            templateConfig: {},\n        };\n        const isNonPrimitiveType = ['array', 'object'].indexOf(attributeMappingObject._type) > -1;\n        let attrMapping = isNonPrimitiveType ? attributeMappingObject._mapping : attributeMappingObject;\n\n        for (let key in attrMapping) {\n            // TODO: Skip attributes should be configurable\n            if (['id'].indexOf(key) > -1) continue;\n\n            let resolved = null;\n            let currentTemplateConfig = null;\n            let current = attrMapping[key];\n\n            // Object or Array\n            if (['object', 'array'].indexOf(current._type) > -1) {\n                if (current._type === 'array') {\n                    resolved = Ng2FormFactory.handleArray(current, key, formBuilder);\n                } else {\n                    // Handle Object\n                    let child = Ng2FormFactory.prepareAndCreateChildTemplateConfig(current, key, formBuilder)();\n\n                    resolved = {\n                        groupType: 'object',\n                        control: child.ngFormControl instanceof FormGroup ?\n                            child.ngFormControl : new FormGroup(child.ngFormControl, Ng2FormFactory.resolveFormValidators(child).validators),\n                        children: child.templateConfig\n                    };\n                }\n            }\n            // Primitive type and date\n            else if (current._type !== 'any') {\n                if (current !== 'undefined' && typeof current._type != 'undefined') {\n                    let { validators, valueNotEmpty } = Ng2FormFactory.resolveFormValidators(current);\n\n                    currentTemplateConfig = {\n                        type: current._type,\n                        control: new FormControl(valueNotEmpty ? current._value : '', validators)\n                    };\n                } else {\n                    resolved = resolveTypeUndefined ? resolveTypeUndefined(current, key) : null; // Resolve as null first\n                }\n            }\n            // Last case: Null value => any\n            else {\n                resolved = resolveTypeAny ? resolveTypeAny(current, key) : null; // Resolve as null first\n            }\n\n            // If resolved is still null, set it to default\n            if (!currentTemplateConfig && !resolved) {\n                let { validators } = Ng2FormFactory.resolveFormValidators(current);\n\n                resolved = {\n                    type: 'string',\n                    renderType: 'text',\n                    control: new FormControl('', validators)\n                };\n            }\n\n            // FIXME: this checking might be redundant\n            if (resolved) {\n                currentTemplateConfig = resolved;\n            }\n\n            currentTemplateConfig.label = Ng2FormFactory.generateLabel(key);\n            currentTemplateConfig.setValue = Ng2FormFactory.factorySetValueFunctionToTemplate(currentTemplateConfig);\n            Ng2FormFactory.resolveTemplateConfigByType(\n                current, currentTemplateConfig\n            );\n\n            result.ngFormControl[key] = currentTemplateConfig.control;\n            result.templateConfig[key] = currentTemplateConfig;\n        }\n\n        result.templateConfig.setValue = Ng2FormFactory.factorySetValueFunctionToTemplate(result.templateConfig);\n\n        if (isNonPrimitiveType) {\n            result.templateConfig = {\n                groupType: attributeMappingObject.type,\n                children: result.templateConfig\n            };\n\n            Ng2FormFactory.setTemplatePreset(attributeMappingObject, result.templateConfig);\n        }\n\n        return result;\n    }\n\n    static resolveFormValidators(current: any) {\n        let validators = current.formFactory && current.formFactory.validators ? current.formFactory.validators : [],\n            valueNotEmpty = [undefined, null].indexOf(current._value) === -1;\n\n        validators = typeof validators === 'function' ? validators(Ng2FormFactory.diContainer) : validators;\n\n        if (valueNotEmpty && validators.length === 0) validators.push(Validators.required);\n\n        return { validators, valueNotEmpty };\n    }\n\n    private static prepareAndCreateChildTemplateConfig(\n        currentInput: any,\n        key: string,\n        formBuilder: FormBuilder,\n        isRaw:boolean = false\n    ) {\n        const lambda = function () {\n            let current = null;\n\n            if (isRaw) {\n                // Mock an array type with targeted Prototype\n                current = new NonPrimitiveTypeMeta(\n                    'array',\n                    Extractor.generateMapping(\n                        new currentInput()\n                    )\n                );\n            } else {\n                current = currentInput;\n            }\n\n            let schemaTemp = null;\n\n            if (\n                'type' in current._mapping &&\n                [\n                    'any',\n                    'string',\n                    'boolean',\n                    'number',\n                    'date',\n                    ''\n                ].indexOf(current._mapping.type) > -1\n            ) {\n                // For primitive type array\n                let control = new FormControl(\n                    'value' in current._mapping ? current._mapping.value : '',\n                    [Validators.required]\n                ), templateConfig = {};\n\n                templateConfig[key] = {\n                    label: Ng2FormFactory.generateLabel(key),\n                    type: current._mapping.type,\n                    control,\n                };\n\n                schemaTemp = {\n                    ngFormControl: control,\n                    templateConfig\n                };\n\n                Ng2FormFactory.resolveTemplateConfigByType(\n                    current._mapping, templateConfig[key]\n                );\n            } else {\n                // For reference type array or object\n                schemaTemp = Ng2FormFactory.generateFormGroupByOATMapping(formBuilder, current._mapping);\n            }\n\n            schemaTemp.templateConfig.setValue = Ng2FormFactory.factorySetValueFunctionToTemplate(schemaTemp.templateConfig);\n\n            if ('formFactory' in current && typeof current.formFactory.onCreate === 'function') {\n                current.formFactory.onCreate(\n                    schemaTemp.templateConfig, Ng2FormFactory.diContainer\n                );\n            }\n\n            return {\n                ngFormControl:\n                    schemaTemp.ngFormControl instanceof FormControl || current.type === 'object' ?\n                        schemaTemp.ngFormControl :\n                        // For reference type array\n                        new FormGroup(schemaTemp.ngFormControl, Ng2FormFactory.resolveFormValidators(schemaTemp).validators),\n                templateConfig: schemaTemp.templateConfig\n            };\n        };\n\n        return lambda;\n    }\n\n    private static handleArray(current: any, key: string, formBuilder: FormBuilder) {\n        let ngFormArrayControl = new FormArray([], Ng2FormFactory.resolveFormValidators(current).validators);\n        let initChildren = [];\n        let arrayType = null;\n\n        let result = {\n            groupType: 'array',\n            arrayType:\n                current.formFactory && current.formFactory.arrayType ?\n                    arrayType :\n                    'type' in current._mapping ?\n                        'primitive' : 'object'\n            ,\n            control: ngFormArrayControl,\n            children: [],\n            childrenConfigName:[],\n            useConfig: 0,\n            add: null,\n            remove: null\n        };\n\n        if (current.formFactory && current.formFactory.objectDefinitions) {\n            let i = 0;\n            current.formFactory.objectDefinitions.forEach(function (each) {\n                initChildren[i] = Ng2FormFactory.prepareAndCreateChildTemplateConfig(each.structure, '', formBuilder, true);\n                result.childrenConfigName[i] = each.label;\n                i += 1;\n            });\n        } else {\n            initChildren[0] = Ng2FormFactory.prepareAndCreateChildTemplateConfig(current, key, formBuilder)\n        }\n\n        let add = function () {\n                let childConfig = initChildren[result.useConfig]();\n\n                const control = <FormArray>ngFormArrayControl;\n                control.push(childConfig.ngFormControl);\n                result.children.push(childConfig.templateConfig);\n\n                childConfig.templateConfig.flexibleObjectTypeName = result.childrenConfigName[result.useConfig];\n\n                if ('formFactory' in current && typeof current.formFactory.onPush === 'function') {\n                    current.formFactory.onPush(\n                        childConfig.templateConfig, Ng2FormFactory.diContainer\n                    );\n                }\n            },\n            remove = function (i: number) {\n                const control = <FormArray>ngFormArrayControl;\n                control.removeAt(i);\n                result.children.splice(i, 1);\n            };\n\n        result.add = add;\n        result.remove = remove;\n\n        // Ng2FormFactory.setTemplatePreset(current, result);\n\n        return result;\n    }\n\n    static factorySetValueFunctionToTemplate(templateObject) {\n        const lambda = function (rawValue) {\n            for (var key in rawValue) {\n                let targetTemplate = templateObject.groupType ? templateObject.children : templateObject;\n\n                if (key in targetTemplate) {\n                    if (targetTemplate[key].type) {\n                        if (typeof rawValue[key] != 'object') {\n                            if (\n                                'beforeSetValue' in targetTemplate[key]\n                            ) {\n                                targetTemplate[key].beforeSetValue(targetTemplate[key], rawValue);\n                            }\n\n                            targetTemplate[key].control.setValue(\n                                // Do not cast to string or boolean value will be broken\n                                rawValue[key]\n                            );\n\n                            if (\n                                'afterSetValue' in targetTemplate[key]\n                            ) {\n                                targetTemplate[key].afterSetValue(targetTemplate[key], rawValue);\n                            }\n                        } else if (typeof rawValue[key] != 'undefined' || rawValue[key] != null) { // skip if rawValue[key] is null or undefined\n                            // debugger;\n                            // Something goes wrong\n                        }\n                    } else {\n                        // For Object\n                        if (targetTemplate[key].groupType === 'object') {\n                            // Let FormGroup to handle value setting\n                            targetTemplate[key].setValue(rawValue[key]);\n                        } else {\n                            // Even this field is array, rawValue[key] can be null\n                            if (!rawValue[key]) continue;\n\n                            // Array\n                            // Remove all elements\n                            while (targetTemplate[key].control.controls.length > 0) {\n                                targetTemplate[key].remove(0);\n                            }\n\n                            let i = 0;\n\n                            rawValue[key].forEach(function (each) {\n                                if (\n                                    'resolveFlexibleObjectArrayConfig' in targetTemplate[key]\n                                ) {\n                                    targetTemplate[key].useConfig = targetTemplate[key].resolveFlexibleObjectArrayConfig(each);\n                                }\n\n                                targetTemplate[key].add();\n\n                                let fixForPrimitiveArray = {};\n                                fixForPrimitiveArray[key] = each;\n\n                                targetTemplate[key].children[i].setValue(\n                                    targetTemplate[key].arrayType !== 'object' ? fixForPrimitiveArray : each\n                                );\n\n                                i++;\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        return lambda;\n    }\n\n    static resolveTemplateConfigByType(attrMapping, templateObj) {\n        if (attrMapping.type === 'boolean') {\n            templateObj.renderType = attrMapping.expandOptions ? 'radio' : 'checkbox';\n        } else if (attrMapping.options) {\n            if (attrMapping.options.length > 2 && attrMapping.maxChoices) {\n                templateObj.renderType = attrMapping.expandOptions ? (\n                    attrMapping.maxChoices == 1 ?\n                        'radio' : 'checkbox'\n                ) : 'select';\n            } else {\n                templateObj.renderType = attrMapping.expandOptions ? 'radio' : 'checkbox';\n            }\n        } else {\n            templateObj.renderType = attrMapping.type;\n            if (templateObj.type === 'string') templateObj.renderType = 'text';\n        }\n\n        Ng2FormFactory.setTemplatePreset(attrMapping, templateObj);\n    }\n\n    // Copy setting from OAT to templateConfig object\n    static setTemplatePreset(attrMapping, templateObj) {\n        [\n            'label',\n            'type',\n            'useComponent',\n            'beforeSetValue',\n            'afterSetValue',\n            'resolveFlexibleObjectArrayConfig',\n            'maxChoices',\n            'expandOptions',\n            'options',\n            'hints',\n            'hide',\n            'html',\n            'renderType',\n            'arrayType',\n            'autocomplete',\n            'matExtra',\n        ].forEach(function (each) {\n            if (attrMapping.formFactory && each in attrMapping.formFactory) {\n                templateObj[each] = attrMapping.formFactory[each];\n            }\n        });\n\n        templateObj.diContainer = Ng2FormFactory.diContainer;\n    }\n}\n","import {Pipe} from \"@angular/core\";\n\n@Pipe({\n    name: 'mapToIterable'\n})\nexport class MapToIterable {\n    transform(object: Object): Array<any> {\n        let result = [];\n\n        for (let key of Object.keys(object)) {\n            if (object.hasOwnProperty(key)) {\n                result.push({key, val: object[key]});\n            }\n        }\n\n        return result;\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { BrowserAnimationsModule } from \"@angular/platform-browser/animations\";\nimport { MatAutocompleteModule } from \"@angular/material/autocomplete\";\nimport { MatButtonModule } from \"@angular/material/button\";\nimport { MatButtonToggleModule } from \"@angular/material/button-toggle\";\nimport { MatCardModule } from \"@angular/material/card\";\nimport { MatCheckboxModule } from \"@angular/material/checkbox\";\nimport { MatDatepickerModule } from \"@angular/material/datepicker\";\nimport { MatExpansionModule } from \"@angular/material/expansion\";\nimport { MatInputModule } from \"@angular/material/input\";\nimport { MatNativeDateModule } from \"@angular/material/core\";\nimport { MatRadioModule } from \"@angular/material/radio\";\nimport { MatSelectModule } from \"@angular/material/select\";\n\nimport {\n    HbFormArrayComponent,\n    HbFormMatArrayComponent,\n    HbFormObjectComponent,\n    HbFormMatObjectComponent,\n    HbFormWidgetComponent,\n    HbFormMatWidgetComponent\n} from '../public-api';\nimport { IBaseFormConfig } from \"./class/decorators/FormConfig\";\nimport { IChoiceOptionsFormConfig } from \"./class/decorators/ChoiceOptions\";\nimport { IArrayOptionsFormConfig } from \"./class/decorators/ArrayOptions\";\nimport { MapToIterable } from \"./pipe/MapToIterable\";\n\nconst directivesAndPipes = [\n    HbFormArrayComponent,\n    HbFormMatArrayComponent,\n    HbFormObjectComponent,\n    HbFormMatObjectComponent,\n    HbFormWidgetComponent,\n    HbFormMatWidgetComponent,\n    MapToIterable,\n];\n\n@NgModule({\n    imports: [\n        FormsModule,\n        ReactiveFormsModule,\n\n        // Material Design\n        BrowserAnimationsModule,\n        MatAutocompleteModule,\n        MatButtonModule,\n        MatButtonToggleModule,\n        MatCardModule,\n        MatCheckboxModule,\n        MatDatepickerModule,\n        MatExpansionModule,\n        MatInputModule,\n        MatNativeDateModule,\n        MatRadioModule,\n        MatSelectModule\n    ],\n    declarations: directivesAndPipes,\n    exports: [\n        BrowserAnimationsModule,\n        MatAutocompleteModule,\n        MatButtonModule,\n        MatButtonToggleModule,\n        MatCardModule,\n        MatCheckboxModule,\n        MatDatepickerModule,\n        MatExpansionModule,\n        MatInputModule,\n        MatNativeDateModule,\n        MatRadioModule,\n        MatSelectModule,\n        ...directivesAndPipes,\n    ]\n})\nexport class HbFormModule {\n}\n\n// Actually template object is way more complicated. Types in here have not address all attributes but configurable only\nexport type TemplateObjectType = IBaseFormConfig | IChoiceOptionsFormConfig | IArrayOptionsFormConfig;\n\nexport interface ICustomComponent {\n    // TemplateObjectType\n    templateObject: any;\n    parentTemplateObject: any;\n}\n\nexport interface ICustomComponentConstructor {\n    new (...deps: any[]): ICustomComponent;\n}\n"]}